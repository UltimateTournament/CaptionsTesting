import * as dotenv from "dotenv"
dotenv.config()

import { Hono } from "hono"
import { v4 as uuidv4 } from "uuid"

import { logger } from "./logger/index"
import { broadcastDevReady } from "@remix-run/node"

import sourceMapSupport from "source-map-support"
sourceMapSupport.install()

// import * as build from "@remix-run/dev/server-build"
import * as build from "../build/index.js"
import { remix } from "remix-hono/handler"
import { cors } from "hono/cors"
import { serveStatic } from "hono/bun"
import { Server, ServerWebSocket } from "bun"
import WebSocket from "ws"

const listenPort = process.env.PORT || "8080"

declare global {
  namespace NodeJS {
    interface ProcessEnv {
      DEEPGRAM_KEY: string
    }
  }
}

declare module "hono" {
  interface ContextVariableMap {
    requestID: string
  }
}

// Generated by https://quicktype.io

export interface DeepgramPayload {
  type:          string;
  channel_index: number[];
  duration:      number;
  start:         number;
  is_final:      boolean;
  speech_final:  boolean;
  channel:       {
    alternatives: {
      transcript: string;
      confidence: number;
      words:      {
        word:       string;
        start:      number;
        end:        number;
        confidence: number;
      }[];
    }[];
  };
  metadata:      {
    request_id: string;
    model_info: {
      name:    string;
      version: string;
      arch:    string;
    };
    model_uuid: string;
  };
}




const app = new Hono<{
  Bindings: {
    server: Server
  }
}>()
app.use(cors())

app.use(async (c, next) => {
  c.set("requestID", uuidv4())
  await next()
})

if (process.env.HTTP_LOG === "1") {
  logger.debug("using HTTP logger")
  app.use(async (c, next) => {
    logger.info(
      {
        method: c.req.method,
        url: c.req.url,
        id: c.get("requestID"),
      },
      "http request"
    )
    await next()
    logger.info(
      {
        method: c.req.method,
        url: c.req.url,
        id: c.get("requestID"),
        status: c.res.status,
      },
      "http response"
    )
  })
}

app.get("/hc", (c) => {
  return c.text("ok")
})

interface WSdata {
  deepgram: WebSocket
}

app.get("/ws", async (c) => {
  // Connect to deepgram and pass through the websocket connection
  const dgWS = new WebSocket(
    "wss://api.deepgram.com/v1/listen?model=nova-2-general&encoding=opus&channels=1&sample_rate=128000&language=en-US",
    {
      headers: {
        Authorization: `Token ${process.env.DEEPGRAM_KEY}`,
      },
    }
  )
  dgWS.onmessage = (msg) => {
    const payload: DeepgramPayload = JSON.parse(msg.data as string)
    console.log("got msg from deepgram", payload, payload?.channel?.alternatives[0].transcript)
  }
  dgWS.onclose = (msg) => {
    console.log("dg ws closed", msg)
  }
  dgWS.onerror = (msg) => {
    console.log("dg ws err", msg)
  }
  dgWS.onopen = (msg) => {
    console.log("DG socket open")
    // setInterval(() => {
    //   console.log('sending keepalive')
    //   dgWS.send(JSON.stringify({ "type": "KeepAlive" }))
    // }, 3000)
  }
  if (
    !c.env.server.upgrade(c.req.raw, {
      data: {
        deepgram: dgWS,
      },
    })
  ) {
    logger.error("failed to upgrade!")
  }
  return new Response() // have to return empty response so hono doesn't get mad
})

app.use("/build/*", serveStatic({ root: "./public" }))
app.use("*", remix({ build: build as any, mode: process.env.NODE_ENV as any }))

if (process.env.NODE_ENV === "development") {
  broadcastDevReady(build as any)
}
logger.info(`API listening on port ${listenPort}`)

const server = Bun.serve({
  port: process.env.PORT || "8080",
  fetch: (req: Request, server: Server) => {
    return app.fetch(req, {
      server,
    })
  },
  websocket: {
    message(ws: ServerWebSocket<WSdata>, msg) {
      const b = msg as Buffer
      // console.log("Sending buffer to Deepgram", msg.length)
      ws.data.deepgram.send(b)
    },
    open(ws) {
      console.log("websocket opened", ws.data)
    },
  },
})

const signals = {
  SIGHUP: 1,
  SIGINT: 2,
  SIGTERM: 15,
}

let stopping = false

Object.keys(signals).forEach((signal) => {
  process.on(signal, async () => {
    if (stopping) {
      return
    }
    stopping = true
    logger.info(`Received signal ${signal}, shutting down...`)
    logger.info("exiting...")
    logger.flush() // pino actually fails to flush, even with awaiting on a callback
    server.stop()
    process.exit(0)
  })
})
